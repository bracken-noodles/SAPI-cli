#!/usr/bin/env node

import http from "http";
import fs from "fs";
import path from "path";
import Ajv from "ajv";
import { SwaggerConfig, ProxyItem, HttpRequestMethod } from "./index.d";
import opsConfigJsonSchemaValidatorv from "./configJsonSchema";

const projectRoot = process.cwd();
const ajv = new Ajv();

var validate = ajv.compile(opsConfigJsonSchemaValidatorv);

const enterprisePrefix = `/enterprises/{enterpriseId}`;
const projectPrefix = enterprisePrefix + `/projects/{projectId}`;

let fileStr = `/*
 * This file was generated by npm scr ipt
 * NEVER MODIFY THIS BY HAND.
 * Go to README.md#swagger-api for more information
 */

import send from "@dc/request"
`;

const configFilePath = path.resolve(projectRoot, "./ops.config.js");

if (fs.existsSync(configFilePath)) {
  const swagger: SwaggerConfig = require(configFilePath).swagger;
  const valid: boolean | PromiseLike<any> = validate(swagger);

  if (!valid) {
    console.error("ops.config.js swagger field config schema wrong. errors:");
    console.error(
      (validate.errors || [])
        .map((err: any, index: number) => index + 1 + ". " + err.message)
        .join("\n  ")
    );
  } else {
    const configs = swagger.proxy;

    let count = 0;

    configs.forEach((config: ProxyItem) => {
      parser(config).then(_ => {
        count += 1;
        if (count === configs.length) {
          fs.writeFileSync(swagger.dist, fileStr, "utf8");
        }
      });
    });
  }
} else {
  console.error(`
  Cannot find ops.config.js at project root.
  Reference: http://rdk.decobim.com/sapi-cli
  `);
  process.exit(1);
}

function parser(config: ProxyItem) {
  return new Promise((resolve, reject) => {
    http.get(config.swaggerJSON, function(res) {
      res.setEncoding("utf8");

      let swaggerJSONStr = "";
      res.on("data", str => (swaggerJSONStr += str));

      res.on("end", function() {
        const infoObj = JSON.parse(swaggerJSONStr);

        Object.keys(infoObj.paths).forEach((path: string) => {
          Object.keys(infoObj.paths[path]).forEach((type: string) => {
            const pathWithPrefix = config.prefix + path;

            const query: any = {};
            const body: any = {};
            const data: [string, string, any, any] = [
              type,
              pathWithPrefix,
              query,
              body
            ];

            const currentRequestObject = infoObj.paths[path][type];

            (currentRequestObject.parameters || []).forEach((param: any) => {
              if (param.in === "query") {
                query[param.name] = param.required;
              } else if (param.in === "body") {
                if (param.schema && param.schema.$ref) {
                  const name = param.schema.$ref.replace("#/definitions/", "");
                  Object.keys(infoObj.definitions[name].properties).forEach(
                    property => {
                      body[property] =
                        infoObj.definitions[name].properties[property].type;
                    }
                  );
                } else if (param.schema && param.schema.type === "array") {
                  body.isArray = true;
                  body.key = param.name;
                }
              }
            });

            fileStr += getCode(
              type,
              currentRequestObject.description,
              generateRequestIdFromPath(type, path, config.namespace),
              data
            );
          });
        });

        resolve();
      });
    });
  });
}

function getCode(
  type: string,
  description: string,
  variableName: string,
  data: any
) {
  return `
// ${type} ${description || ""}
export const ${variableName} = (params) => send(${JSON.stringify(
    data
  )},params)`;
}

const isProjectPath = (path: string) => path.startsWith(projectPrefix);
const isEnterprisePath = (path: string) => path.startsWith(enterprisePrefix);

function generateRequestIdFromPath(
  method: string | HttpRequestMethod,
  path: string,
  namespace: string
) {
  let mainQueue: (string | HttpRequestMethod)[] = namespace ? [namespace] : [];
  let paramQueue: string[] = [];

  mainQueue.push(method);

  if (isProjectPath(path)) {
    mainQueue.push("project");
    path = path.replace(projectPrefix, "");
  } else if (isEnterprisePath(path)) {
    mainQueue.push("enterprise");
    path = path.replace(enterprisePrefix, "");
  }

  const pathQueue: string[] = path.split("/");

  pathQueue.forEach((currentParamater: string, index: number) => {
    if (/^{\w+}$/.test(currentParamater)) {
      // current is paramater;
      const matchInfo: any = currentParamater.match(/{(\w+)}/);

      if (!matchInfo[1]) {
        currentParamater = "";
      } else {
        currentParamater = matchInfo[1].replace("Id", "");
      }

      paramQueue.push(currentParamater);

      if (currentParamater !== "mobile") {
        delete pathQueue[index - 1];
      }

      delete pathQueue[index];
    }
  });

  pathQueue.filter(path => !!path);

  mainQueue = mainQueue.concat(pathQueue);

  if (paramQueue.length) {
    mainQueue = mainQueue.concat(["With"], paramQueue);
  }

  const variableName = mainQueue.reduce(
    (
      result: string | HttpRequestMethod,
      element: string | HttpRequestMethod
    ) => {
      if (!element) return result;

      return result + toBigCamel(element);
    }
  );

  return variableName;
}

function toBigCamel(str: string | HttpRequestMethod) {
  return (
    str.charAt(0).toUpperCase() +
    str.slice(1).replace(/-\w/g, match => match.charAt(1).toUpperCase())
  );
}
